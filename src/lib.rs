//! # Workflow Engine
//!
//! A library for parsing and executing workflow YAML files with interactive argument resolution.
//!
//! This crate provides functionality to:
//! - Parse workflow definitions from YAML files
//! - Resolve arguments interactively (text input, enum selection)
//! - Execute commands with template variable substitution
//! - Provide rich user feedback with progress indicators

use anyhow::{Context as AnyhowContext, Result};
use indicatif::ProgressBar;
use inquire::{Select, Text};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::process::Command;
use tera::{Context, Tera};

pub mod autocomplete;
pub mod config;
pub mod text;

/// Represents a complete workflow definition parsed from YAML.
///
/// A workflow contains metadata, a command template with placeholder variables,
/// and a list of arguments that need to be resolved before execution.
///
/// # Example YAML structure
/// ```yaml
/// name: "My Workflow"
/// command: "echo {{message}}"
/// description: "Prints a message"
/// arguments:
///   - name: message
///     arg_type: Text
///     description: "Message to print"
///     default_value: "Hello World"
/// tags: ["example"]
/// shells: ["bash", "zsh"]
/// ```
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Workflow {
    /// Human-readable name of the workflow
    pub name: String,
    /// Command template with {{variable}} placeholders to be executed
    pub command: String,
    /// Description explaining what the workflow does
    pub description: String,
    /// List of arguments that need to be resolved before execution
    pub arguments: Vec<WorkflowArgument>,
    /// Tags for categorizing workflows
    pub tags: Vec<String>,
    /// Optional URL to the workflow source
    pub source_url: Option<String>,
    /// Optional workflow author name
    pub author: Option<String>,
    /// Optional URL to author's profile/website
    pub author_url: Option<String>,
    /// List of supported shell environments [TODO: add support for other shells]
    pub shells: Vec<String>,
}

/// Represents a single argument that needs to be resolved before workflow execution.
///
/// Arguments can be of different types and have different resolution mechanisms:
/// - Text/Number/Boolean: User input prompts with optional defaults
/// - Enum: Dynamic options retrieved by executing a command
///
/// # Example YAML structures
/// ```yaml
/// # Simple text argument with default
/// - name: message
///   arg_type: Text  # Optional, defaults to Text
///   description: "Message to display"
///   default_value: "Hello"
///
/// # Enum argument that gets options dynamically
/// - name: namespace
///   arg_type: Enum
///   description: "Kubernetes namespace"
///   enum_name: "namespaces"
///   enum_command: "kubectl get namespaces --no-headers | awk '{print $1}'"
///
/// # Required argument (no default)
/// - name: filename
///   description: "File to process"
///   default_value: ~  # ~ means null/no default
/// ```
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct WorkflowArgument {
    /// Variable name used in command template (e.g., {{name}})
    pub name: String,
    /// Type of argument - determines resolution method
    #[serde(default = "default_arg_type")]
    pub arg_type: ArgumentType,
    /// Human-readable description shown in prompts
    pub description: String,
    /// Optional default value (use ~ for null/no default)
    pub default_value: Option<String>,
    /// For Enum type: identifier for the dynamic option set
    pub enum_name: Option<String>,
    /// For Enum type: command to execute to get available options
    pub enum_command: Option<String>,
    /// For Enum type: static list of predefined options
    pub enum_variants: Option<Vec<String>>,
    /// For Enum type: name of the argument to reference for dynamic resolution in enum_command
    pub dynamic_resolution: Option<String>,
}

/// Returns the default argument type when not specified in YAML.
fn default_arg_type() -> ArgumentType {
    ArgumentType::Text
}

/// Defines the different types of arguments supported by workflows.
///
/// Each type has a different resolution mechanism:
/// - `Text`: Free text input from user
/// - `Enum`: Selection from dynamically generated options
/// - `Number`: Numeric input (validated as number)
/// - `Boolean`: True/false selection
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "PascalCase")]
pub enum ArgumentType {
    /// Free text input with optional default value
    Text,
    /// Selection from options generated by executing a command
    Enum,
    /// Numeric input (stored as string but validated)
    Number,
    /// Boolean true/false input
    Boolean,
}

impl Workflow {
    /// Parse a workflow from YAML content.
    ///
    /// # Arguments
    /// * `yaml_content` - The YAML string content to parse
    ///
    /// # Returns
    /// * `Ok(Workflow)` - Successfully parsed workflow
    /// * `Err(serde_yaml::Error)` - YAML parsing error with details
    ///
    /// # Example
    /// ```rust
    /// use workflow::Workflow;
    ///
    /// let yaml = r#"
    /// name: "Test Workflow"
    /// command: "echo {{message}}"
    /// description: "A test workflow"
    /// arguments:
    ///   - name: message
    ///     description: "Message to echo"
    /// tags: []
    /// shells: ["bash"]
    /// "#;
    ///
    /// let workflow = Workflow::from_yaml(yaml).unwrap();
    /// assert_eq!(workflow.name, "Test Workflow");
    /// ```
    pub fn from_yaml(yaml_content: &str) -> Result<Self, serde_yaml::Error> {
        serde_yaml::from_str(yaml_content)
    }

    /// Serialize a workflow back to YAML format.
    ///
    /// # Returns
    /// * `Ok(String)` - YAML representation of the workflow
    /// * `Err(serde_yaml::Error)` - Serialization error
    pub fn to_yaml(&self) -> Result<String, serde_yaml::Error> {
        serde_yaml::to_string(self)
    }

    /// Execute the workflow by resolving all arguments and running the command.
    ///
    /// This is the main entry point for workflow execution. It performs the following steps:
    /// 1. Display workflow information
    /// 2. Resolve all arguments interactively (with progress indicators)
    /// 3. Render the command template with resolved values
    /// 4. Execute the final command
    /// 5. Display results
    ///
    /// # Returns
    /// * `Ok(())` - Workflow executed successfully
    /// * `Err(anyhow::Error)` - Error during argument resolution, template rendering, or command execution
    ///
    /// # Example
    /// ```rust,no_run
    /// use workflow::Workflow;
    ///
    /// # async fn example() -> anyhow::Result<()> {
    /// let yaml = r#"
    /// name: "Test Workflow"
    /// command: "echo {{message}}"
    /// description: "A test workflow"
    /// arguments:
    ///   - name: message
    ///     description: "Message to echo"
    ///     default_value: "Hello World"
    /// tags: []
    /// shells: ["bash"]
    /// "#;
    ///
    /// let workflow = Workflow::from_yaml(yaml)?;
    /// workflow.execute().await?;
    /// # Ok(())
    /// # }
    /// ```
    pub async fn execute(&self) -> Result<()> {
        print!(
            "{}",
            text::t_params(
                "execution_workflow_header",
                &[&self.name, &self.description]
            )
        );

        let mut argument_values = HashMap::new();

        for arg in &self.arguments {
            let value = self.resolve_argument(arg, &argument_values).await?;
            argument_values.insert(arg.name.clone(), value);
        }

        let final_command = self.render_command(&argument_values)?;

        println!("{}", text::t("command_executing_header"));
        println!("{}", final_command);
        println!();

        self.run_command(&final_command).await?;

        Ok(())
    }

    /// Resolve a single argument based on its type.
    ///
    /// Dispatches to the appropriate resolution method:
    /// - Enum arguments: Execute command and show selection menu
    /// - Other types: Show input prompt with optional default
    ///
    /// # Arguments
    /// * `arg` - The argument definition to resolve
    /// * `current_values` - Currently resolved argument values for dynamic resolution
    ///
    /// # Returns
    /// * `Ok(String)` - The resolved argument value
    /// * `Err(anyhow::Error)` - Error during resolution
    async fn resolve_argument(
        &self,
        arg: &WorkflowArgument,
        current_values: &HashMap<String, String>,
    ) -> Result<String> {
        match arg.arg_type {
            ArgumentType::Enum => {
                if let Some(enum_variants) = &arg.enum_variants {
                    // Static enum variants
                    self.resolve_static_enum_argument(arg, enum_variants)
                } else if let (Some(enum_command), Some(enum_name)) =
                    (&arg.enum_command, &arg.enum_name)
                {
                    // Dynamic enum via command
                    self.resolve_enum_argument(arg, enum_command, enum_name, current_values)
                        .await
                } else {
                    anyhow::bail!(text::t_params("enum_args_missing_config", &[&arg.name]));
                }
            }
            ArgumentType::Text | ArgumentType::Number | ArgumentType::Boolean => {
                self.resolve_simple_argument(arg)
            }
        }
    }

    /// Resolve an enum argument using static predefined variants.
    ///
    /// This method presents a searchable selection menu with the predefined options
    /// from the `enum_variants` field, allowing users to search, select, or type custom values.
    ///
    /// # Arguments
    /// * `arg` - The argument definition
    /// * `variants` - The predefined list of options
    ///
    /// # Returns
    /// * `Ok(String)` - The selected option or custom input
    /// * `Err(anyhow::Error)` - User interaction error
    fn resolve_static_enum_argument(
        &self,
        arg: &WorkflowArgument,
        variants: &[String],
    ) -> Result<String> {
        if variants.is_empty() {
            anyhow::bail!(text::t_params("enum_args_no_options_found", &[&arg.name]));
        }

        let prompt = if arg.description.is_empty() || arg.description == "~" {
            arg.name.clone()
        } else {
            arg.description.clone()
        };

        // Use searchable selection with inquire
        let selection = Select::new(&prompt, variants.to_vec())
            .with_page_size(10)
            .with_help_message(&text::t("enum_args_searchable_help"))
            .prompt()
            .with_context(|| text::t("errors_selection_failed"))?;

        Ok(selection)
    }

    /// Resolve an enum argument by executing a command and presenting options.
    ///
    /// This method:
    /// 1. Shows a spinner while executing the enum command
    /// 2. Parses the command output into selectable options
    /// 3. Presents a searchable selection menu allowing search, selection, or custom input
    /// 4. Supports dynamic resolution using previously resolved arguments
    ///
    /// # Arguments
    /// * `arg` - The argument definition containing description
    /// * `enum_command` - Shell command to execute to get options
    /// * `_enum_name` - Identifier for the enum (unused but kept for future features)
    /// * `current_values` - Currently resolved argument values for dynamic resolution
    ///
    /// # Returns
    /// * `Ok(String)` - The selected option value or custom input
    /// * `Err(anyhow::Error)` - Command execution failure or user interaction error
    async fn resolve_enum_argument(
        &self,
        arg: &WorkflowArgument,
        enum_command: &str,
        _enum_name: &str,
        current_values: &HashMap<String, String>,
    ) -> Result<String> {
        let spinner = ProgressBar::new_spinner();
        spinner.set_style(text::spinners::enum_spinner_style());
        spinner.set_message(text::t_params("enum_args_getting_options", &[&arg.name]));
        spinner.enable_steady_tick(std::time::Duration::from_millis(100));

        // Handle dynamic resolution if specified
        let resolved_command = if let Some(ref_arg) = &arg.dynamic_resolution {
            if let Some(ref_value) = current_values.get(ref_arg) {
                // Substitute the referenced argument value in the enum_command
                enum_command.replace(&format!("{{{{{}}}}}", ref_arg), ref_value)
            } else {
                anyhow::bail!(
                    "Dynamic resolution failed: referenced argument '{}' not found",
                    ref_arg
                );
            }
        } else {
            enum_command.to_string()
        };

        let output = Command::new("sh")
            .arg("-c")
            .arg(&resolved_command)
            .output()
            .with_context(|| {
                text::t_params("errors_enum_command_execution_failed", &[&resolved_command])
            })?;

        spinner.finish_and_clear();

        if !output.status.success() {
            anyhow::bail!(text::t_params(
                "enum_args_command_failed",
                &[&String::from_utf8_lossy(&output.stderr)]
            ));
        }

        let options: Vec<String> = String::from_utf8(output.stdout)?
            .lines()
            .map(|s| s.trim().to_string())
            .filter(|s| !s.is_empty())
            .collect();

        if options.is_empty() {
            anyhow::bail!(text::t_params("enum_args_no_options_found", &[&arg.name]));
        }

        let prompt = if arg.description.is_empty() || arg.description == "~" {
            arg.name.clone()
        } else {
            arg.description.clone()
        };

        // Use searchable selection with inquire
        let selection = Select::new(&prompt, options)
            .with_page_size(10)
            .with_help_message(&text::t("enum_args_searchable_help"))
            .prompt()
            .with_context(|| text::t("errors_selection_failed"))?;

        Ok(selection)
    }

    /// Resolve a simple argument (Text, Number, Boolean) through user input.
    ///
    /// Presents an interactive input prompt with:
    /// - Argument name and description
    /// - Default value if available and not null (~)
    /// - Input validation for the argument type
    ///
    /// # Arguments
    /// * `arg` - The argument definition to resolve
    ///
    /// # Returns
    /// * `Ok(String)` - The user-provided or default value
    /// * `Err(anyhow::Error)` - User interaction error
    fn resolve_simple_argument(&self, arg: &WorkflowArgument) -> Result<String> {
        let prompt = if arg.description.is_empty() || arg.description == "~" {
            arg.name.clone()
        } else {
            arg.description.clone()
        };

        let mut text_input =
            Text::new(&prompt).with_autocomplete(autocomplete::FilePathCompleter::default());

        if let Some(default) = &arg.default_value {
            if !default.is_empty() && default != "~" {
                text_input = text_input.with_default(default);
            }
        }

        text_input
            .prompt()
            .with_context(|| text::t_params("simple_args_input_failed", &[&arg.name]))
    }

    /// Render the command template by substituting argument values.
    ///
    /// Uses the Tera templating engine to replace {{variable}} placeholders
    /// in the command string with the resolved argument values.
    ///
    /// # Arguments
    /// * `arguments` - Map of argument names to resolved values
    ///
    /// # Returns
    /// * `Ok(String)` - The rendered command ready for execution
    /// * `Err(anyhow::Error)` - Template rendering error (usually missing variables)
    ///
    /// # Example
    /// Command: `"echo {{message}} > {{file}}"`
    /// Arguments: `{"message": "Hello", "file": "output.txt"}`
    /// Result: `"echo Hello > output.txt"`
    fn render_command(&self, arguments: &HashMap<String, String>) -> Result<String> {
        let mut tera = Tera::default();
        let mut context = Context::new();

        for (key, value) in arguments {
            context.insert(key, value);
        }

        tera.render_str(&self.command, &context)
            .with_context(|| text::t("templates_render_failed"))
    }

    /// Execute the final rendered command and display results.
    ///
    /// This method:
    /// 1. Shows a spinner while the command executes
    /// 2. Captures both stdout and stderr
    /// 3. Reports success/failure with appropriate messaging
    /// 4. Displays command output if available
    ///
    /// # Arguments
    /// * `command` - The fully rendered command string to execute
    ///
    /// # Returns
    /// * `Ok(())` - Command executed successfully (exit code 0)
    /// * `Err(anyhow::Error)` - Command failed or execution error
    async fn run_command(&self, command: &str) -> Result<()> {
        let status = tokio::process::Command::new("sh")
            .arg("-c")
            .arg(command)
            .status()
            .await
            .with_context(|| text::t("errors_spawn_failed"))?;

        if !status.success() {
            let exit_code = status
                .code()
                .map(|c| c.to_string())
                .unwrap_or_else(|| "unknown".to_string());
            println!(
                "{}",
                text::t_params("command_failed_with_code", &[&exit_code])
            );
            anyhow::bail!(text::t("errors_execution_failed"));
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;

    #[test]
    fn test_parse_scale_kubernetes_pods_yaml() {
        let yaml_content = fs::read_to_string("resource/scale_kubernetes_pods.yaml")
            .expect("Failed to read YAML file");

        let workflow = Workflow::from_yaml(&yaml_content).expect("Failed to parse YAML");

        // Verify the parsed content
        assert_eq!(workflow.name, "Scale Kubernetes Pods");
        assert_eq!(
            workflow.description,
            "Workflow to safely scale down Kubernetes deployments and statefulsets"
        );
        assert_eq!(workflow.arguments.len(), 2);

        // Check namespace argument
        let namespace_arg = &workflow.arguments[0];
        assert_eq!(namespace_arg.name, "namespace");
        assert!(matches!(namespace_arg.arg_type, ArgumentType::Enum));
        assert_eq!(namespace_arg.description, "Namespace to apply scale to");

        assert_eq!(namespace_arg.enum_name.as_ref().unwrap(), "namespaces");
        assert_eq!(
            namespace_arg.enum_command.as_ref().unwrap(),
            "kubectl get namespaces | awk 'NR>1 {print $1}'"
        );

        // Check replica_count argument
        let replica_arg = &workflow.arguments[1];
        assert_eq!(replica_arg.name, "replica_count");
        assert!(matches!(replica_arg.arg_type, ArgumentType::Text));
        assert_eq!(replica_arg.description, "Number of replicas");
        assert_eq!(replica_arg.default_value, Some("0".to_string()));

        println!("âœ… Successfully parsed workflow: {}", workflow.name);
        println!("Command: {}", workflow.command);
        println!(
            "Arguments: {:?}",
            workflow
                .arguments
                .iter()
                .map(|a| &a.name)
                .collect::<Vec<_>>()
        );
    }
}
