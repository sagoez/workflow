//! Core workflow types and data structures

use serde::{Deserialize, Serialize};

/// Represents a complete workflow definition parsed from YAML.
///
/// A workflow contains metadata, a command template with placeholder variables,
/// and a list of arguments that need to be resolved before execution.
///
/// # Example YAML structure
/// ```yaml
/// name: "My Workflow"
/// command: "echo {{message}}"
/// description: "Prints a message"
/// arguments:
///   - name: message
///     arg_type: Text
///     description: "Message to print"
///     default_value: "Hello World"
/// tags: ["example"]
/// shells: ["bash", "zsh"]
/// ```
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct Workflow {
    /// Human-readable name of the workflow
    pub name:        String,
    /// Command template with {{variable}} placeholders to be executed
    pub command:     String,
    /// Description explaining what the workflow does
    pub description: String,
    /// List of arguments that need to be resolved before execution
    pub arguments:   Vec<WorkflowArgument>,
    /// Tags for categorizing workflows
    pub tags:        Vec<String>,
    /// Optional URL to the workflow source
    pub source_url:  Option<String>,
    /// Optional workflow author name
    pub author:      Option<String>,
    /// Optional URL to author's profile/website
    pub author_url:  Option<String>,
    /// List of supported shell environments [TODO: add support for other shells]
    pub shells:      Vec<String>
}

/// Represents a single argument that needs to be resolved before workflow execution.
///
/// Arguments can be of different types and have different resolution mechanisms:
/// - Text/Number/Boolean: User input prompts with optional defaults
/// - Enum: Dynamic options retrieved by executing a command
///
/// # Example YAML structures
/// ```yaml
/// # Simple text argument with default
/// - name: message
///   arg_type: Text  # Optional, defaults to Text
///   description: "Message to display"
///   default_value: "Hello"
///
/// # Enum argument that gets options dynamically
/// - name: namespace
///   arg_type: Enum
///   description: "Kubernetes namespace"
///   enum_name: "namespaces"
///   enum_command: "kubectl get namespaces --no-headers | awk '{print $1}'"
///
/// # Required argument (no default)
/// - name: filename
///   description: "File to process"
///   default_value: ~  # ~ means null/no default
/// ```
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct WorkflowArgument {
    /// Variable name used in command template (e.g., {{name}})
    pub name:               String,
    /// Type of argument - determines resolution method
    #[serde(default = "default_arg_type")]
    pub arg_type:           ArgumentType,
    /// Human-readable description shown in prompts
    pub description:        String,
    /// Optional default value (use ~ for null/no default)
    pub default_value:      Option<String>,
    /// For Enum type: identifier for the dynamic option set
    pub enum_name:          Option<String>,
    /// For Enum type: command to execute to get available options
    pub enum_command:       Option<String>,
    /// For Enum type: static list of predefined options
    pub enum_variants:      Option<Vec<String>>,
    /// For Enum type: name of the argument to reference for dynamic resolution in enum_command
    pub dynamic_resolution: Option<String>
}

/// Returns the default argument type when not specified in YAML.
fn default_arg_type() -> ArgumentType {
    ArgumentType::Text
}

/// Defines the different types of arguments supported by workflows.
///
/// Each type has a different resolution mechanism:
/// - `Text`: Free text input from user
/// - `Enum`: Selection from dynamically generated options
/// - `Number`: Numeric input (validated as number)
/// - `Boolean`: True/false selection
#[derive(Debug, Serialize, Deserialize, Clone)]
#[serde(rename_all = "PascalCase")]
pub enum ArgumentType {
    /// Free text input with optional default value
    Text,
    /// Selection from options generated by executing a command
    Enum,
    /// Numeric input (stored as string but validated)
    Number,
    /// Boolean true/false input
    Boolean
}
